{
  "contractName": "Registry",
  "constructorInputs": [
    {
      "name": "domainCategory",
      "type": "bytes"
    }
  ],
  "abi": [
    {
      "name": "call",
      "inputs": []
    }
  ],
  "bytecode": "OP_TXVERSION OP_2 OP_NUMEQUALVERIFY OP_INPUTINDEX OP_UTXOBYTECODE OP_0 OP_UTXOBYTECODE OP_OVER OP_EQUALVERIFY OP_0 OP_OUTPUTBYTECODE OP_EQUALVERIFY OP_0 OP_UTXOTOKENCATEGORY OP_OVER OP_EQUALVERIFY OP_0 OP_OUTPUTTOKENCATEGORY OP_EQUALVERIFY OP_0 OP_OUTPUTVALUE OP_0 OP_UTXOVALUE OP_NUMEQUALVERIFY OP_0 OP_OUTPUTTOKENCOMMITMENT OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUALVERIFY OP_1 OP_UTXOBYTECODE OP_0 OP_UTXOTOKENCOMMITMENT OP_EQUAL",
  "source": "pragma cashscript ^0.11.0;\n\n/**\n  * @param domainCategory - The category of the domain NFTs that are authorized to be registered. [In reverse order]\n  *\n  * The Registry has two minting NFTs:\n  * 1. CounterMintingNFT, has tokenAmount and nftCommitment.\n  * 2. DomainMintingNFT, does not have any tokenAmount or nftCommitment.\n */\ncontract Registry(bytes domainCategory) {\n  /**\n   * The Registry contract serves as both a source and storage for authorized NFTs.\n   * It holds: RegistrationNFTs, AuctionNFTs, and AuthorizedThreadNFTs\n   *\n   * AuthorizedThreadNFTs are NFTs with immutable capability that share the same category as domainCategory.\n   * These NFTs contain the lockingBytecode of authorized contracts.\n   * Multiple copies of these NFTs enable parallel processing through multiple threads.\n   * \n   * The contract can only be called in conjunction with one of the authorized contracts.\n   *\n   * Imagine that the authorised contracts are just function composition,\n   * those contracts are being used for the code in them and to reduce the transaction size.\n   * This design reduces the transaction size to a minimum while using every OP_CODE required\n   * for a given action. To use the code in these authorized contracts, a random UTXO is used and\n   * sent back to itself to be used again in future.\n   *\n   * All the utxos, except for the DomainNFTs (InternalAuth, ExternalAuth and DomainOwnershipNFT),\n   * stay with the Registry contract.\n   * \n   * @note Authorized contracts and their thread counts:\n   * - Auction:                       [1 thread] (Single-threaded registration)\n   * - Bid:                           [~x threads]\n   * - DomainFactory:                 [~x threads]\n   * - AuctionNameEnforcer:           [~x threads]\n   * - DomainOwnershipGuard:          [~x threads]\n   * - AuctionConflictResolver:       [~x threads]\n   * - Accumulator:                   [~x threads]\n   * \n   * @inputs\n   * - Input0: AuthorizedThreadNFT from self\n   * - Input1: Any UTXO from Authorized contract\n   * \n   * @outputs\n   * - Output0: AuthorizedThreadNFT back to self\n   * - Output1: Output back to Authorized contract to be reused again\n   */\n  function call() {\n    // Added as safeguard.\n    require(tx.version == 2);\n\n    // Registry Contract\n\n    bytes selfLockingBytecode = tx.inputs[this.activeInputIndex].lockingBytecode;\n    // authorizedThreadNFT must stay with the Registry Contract.\n    require(tx.inputs[0].lockingBytecode == selfLockingBytecode);\n    require(tx.outputs[0].lockingBytecode == selfLockingBytecode);\n\n    // Immutable NFTs of domainCategory in Registry Contract will always be authorizedThreadNFTs\n    // Mutable NFTs of domainCategory in Registry Contract will always be auctionNFTs\n    // Minting NFTs of domainCategory in Registry Contract will always be counterMintingNFT or DomainMintingNFT\n    require(tx.inputs[0].tokenCategory == domainCategory);\n    require(tx.outputs[0].tokenCategory == domainCategory);\n    // Keeping the value same to not influence any satoshi movement in authorized contracts\n    require(tx.outputs[0].value == tx.inputs[0].value);\n    // The commitment that has the lockingbytecode of the authorized contract should never change.\n    require(tx.outputs[0].nftCommitment == tx.inputs[0].nftCommitment);\n    // Not checking the tokenAmount as it changes.\n\n    // Authorized Contract\n\n    // Expect the NFT commitment that contains the lockingBytecode of the authorized contract.\n    require(tx.inputs[1].lockingBytecode == tx.inputs[0].nftCommitment);\n    // With these prerequisites met, we just need to make sure that all the contracts that are deployed are written\n    // and initialized properly, and they expect this structure and handle the inputs and outputs as expected.\n  }\n}\n",
  "debug": {
    "bytecode": "c2529c69c0c700c75179876900cd517a876900ce5179876900d1517a876900cc00c69c6900d200cf876951c700cf87",
    "sourceMap": "49:12:49:22;:26::27;:12:::1;:4::29;53:42:53:63:0;:32::80:1;55:22:55:23:0;:12::40:1;:44::63:0;;:12:::1;:4::65;56:23:56:24:0;:12::41:1;:45::64:0;;:12:::1;:4::66;61:22:61:23:0;:12::38:1;:42::56:0;;:12:::1;:4::58;62:23:62:24:0;:12::39:1;:43::57:0;;:12:::1;:4::59;64:23:64:24:0;:12::31:1;:45::46:0;:35::53:1;:12;:4::55;66:23:66:24:0;:12::39:1;:53::54:0;:43::69:1;:12;:4::71;72:22:72:23:0;:12::40:1;:54::55:0;:44::70:1;:12",
    "logs": [],
    "requires": [
      {
        "ip": 4,
        "line": 49
      },
      {
        "ip": 12,
        "line": 55
      },
      {
        "ip": 18,
        "line": 56
      },
      {
        "ip": 24,
        "line": 61
      },
      {
        "ip": 30,
        "line": 62
      },
      {
        "ip": 36,
        "line": 64
      },
      {
        "ip": 42,
        "line": 66
      },
      {
        "ip": 48,
        "line": 72
      }
    ]
  },
  "compiler": {
    "name": "cashc",
    "version": "0.11.0-next.3"
  },
  "updatedAt": "2025-04-19T07:31:30.858Z"
}